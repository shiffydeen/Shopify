import {
  allAPIs,
  blockPartnersAccess,
  getIdentityTokenInformation,
  getPartnersToken,
  hashString,
  nonRandomUUID,
  shopifyFetch,
  z
} from "./chunk-QIECGUO5.js";
import {
  getPackageManager,
  getSession,
  packageManagerFromUserAgent,
  removeSession,
  setSession
} from "./chunk-6AJRDC5C.js";
import {
  AbortError,
  BugError,
  Environment,
  FatalError,
  addPublicMetadata,
  addSensitiveMetadata,
  ciPlatform,
  cloudEnvironment,
  currentProcessIsGlobal,
  firstPartyDev,
  import_ts_error,
  isCI,
  isCloudEnvironment,
  isSpin,
  isTTY,
  isWsl,
  keypress,
  macAddress,
  openURL,
  outputCompleted,
  outputContent,
  outputDebug,
  outputInfo,
  outputToken,
  platformAndArch,
  serviceEnvironment,
  sessionConstants,
  spinFqdn,
  themeToken
} from "./chunk-3Q5VPXT5.js";
import {
  cwd
} from "./chunk-EG6MBBEN.js";
import {
  __commonJS,
  __require,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/network-interfaces@1.1.0/node_modules/network-interfaces/index.js
var require_network_interfaces = __commonJS({
  "../../node_modules/.pnpm/network-interfaces@1.1.0/node_modules/network-interfaces/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var os2 = __require("os");
    function isValid(address, options) {
      return !(typeof options.internal == "boolean" && address.internal !== options.internal || options.ipVersion === 4 && address.family !== "IPv4" || options.ipVersion === 6 && address.family !== "IPv6");
    }
    function findAddresses(interfaceName, options = {}) {
      let addresses = os2.networkInterfaces()[interfaceName];
      if (!addresses)
        throw new Error(`Network interface "${interfaceName}" does not exist`);
      let result = [];
      for (let address of addresses)
        isValid(address, options) && result.push(address);
      return result;
    }
    exports.toIp = function(interfaceName, options) {
      let addresses = findAddresses(interfaceName, options);
      if (addresses.length === 0)
        throw new Error(`No suitable IP address found on interface "${interfaceName}"`);
      return addresses[0].address;
    };
    exports.toIps = function(interfaceName, options) {
      return findAddresses(interfaceName, options).map((address) => address.address);
    };
    exports.fromIp = function(ip, options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces);
      for (let interfaceName of interfaceNames)
        for (let address of interfaces[interfaceName])
          if (address.address === ip && isValid(address, options))
            return interfaceName;
      throw new Error(`No suitable interfaces were found with IP address "${ip}"`);
    };
    exports.getInterface = function(options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces);
      for (let interfaceName of interfaceNames)
        if (findAddresses(interfaceName, options).length > 0)
          return interfaceName;
      throw new Error("No suitable interfaces were found");
    };
    exports.getInterfaces = function(options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces), result = [];
      for (let interfaceName of interfaceNames)
        findAddresses(interfaceName, options).length > 0 && result.push(interfaceName);
      return result;
    };
  }
});

// ../cli-kit/dist/private/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session/identity.js
init_cjs_shims();
function clientId() {
  let environment = serviceEnvironment();
  return environment === Environment.Local ? "e5380e02-312a-7408-5718-e07017e9cf52" : environment === Environment.Production ? "fbdb2649-e327-4907-8f67-908d24cfd7e3" : "e5380e02-312a-7408-5718-e07017e9cf52";
}
function applicationId(api) {
  switch (api) {
    case "admin": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52" : environment === Environment.Production ? "7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c" : "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
    }
    case "partners": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978" : environment === Environment.Production ? "271e16d403dfa18082ffb3d197bd2b5f4479c3fc32736d69296829cbb28d41a6" : "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978";
    }
    case "storefront-renderer": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "46f603de-894f-488d-9471-5b721280ff49" : environment === Environment.Production ? "ee139b3d-5861-4d45-b387-1bc3ada7811c" : "46f603de-894f-488d-9471-5b721280ff49";
    }
    case "business-platform": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "ace6dc89-b526-456d-a942-4b8ef6acda4b" : environment === Environment.Production ? "32ff8ee5-82b8-4d93-9f8a-c6997cefb7dc" : "ace6dc89-b526-456d-a942-4b8ef6acda4b";
    }
    case "app-management":
      return serviceEnvironment() === Environment.Production ? "7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c" : "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
    default:
      throw new BugError(`Application id for API of type: ${api}`);
  }
}

// ../cli-kit/dist/private/node/session/validate.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session/schema.js
init_cjs_shims();
var DateSchema = z.preprocess((arg) => typeof arg == "string" || arg instanceof Date ? new Date(arg) : null, z.date()), IdentityTokenSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string()),
  userId: z.string()
}), ApplicationTokenSchema = z.object({
  accessToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string())
}), SessionSchema = z.object({}).catchall(z.object({
  /**
   * It contains the identity token. Before usint it, we exchange it
   * to get a token that we can use with different applications. The exchanged
   * tokens for the applications are stored under applications.
   */
  identity: IdentityTokenSchema,
  /**
   * It contains exchanged tokens for the applications the CLI
   * authenticates with. Tokens are scoped under the fqdn of the applications.
   */
  applications: z.object({}).catchall(ApplicationTokenSchema)
}));
function validateCachedIdentityTokenStructure(identityToken) {
  return IdentityTokenSchema.safeParse(identityToken).success;
}

// ../cli-kit/dist/private/node/session/validate.js
function validateScopes(requestedScopes, identity) {
  let currentScopes = identity.scopes;
  return firstPartyDev() !== currentScopes.includes("employee") ? !1 : requestedScopes.every((scope) => currentScopes.includes(scope));
}
async function validateSession(scopes, applications, session) {
  if (!session || !validateScopes(scopes, session.identity))
    return "needs_full_auth";
  let tokensAreExpired = isTokenExpired(session.identity);
  if (applications.partnersApi) {
    let appId = applicationId("partners"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.appManagementApi) {
    let appId = applicationId("app-management"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.storefrontRendererApi) {
    let appId = applicationId("storefront-renderer"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.adminApi) {
    let appId = applicationId("admin"), realAppId = `${applications.adminApi.storeFqdn}-${appId}`, token = session.applications[realAppId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  return outputDebug(`- Token validation -> It's expired: ${tokensAreExpired}`), validateCachedIdentityTokenStructure(session.identity) ? tokensAreExpired ? "needs_refresh" : "ok" : "needs_full_auth";
}
function isTokenExpired(token) {
  return token ? token.expiresAt < expireThreshold() : !0;
}
function expireThreshold() {
  return new Date(Date.now() + sessionConstants.expirationTimeMarginInMinutes * 60 * 1e3);
}

// ../cli-kit/dist/private/node/session/scopes.js
init_cjs_shims();
function allDefaultScopes(extraScopes = []) {
  let scopes = allAPIs.map((api) => defaultApiScopes(api)).flat();
  return scopes = ["openid", ...scopes, ...extraScopes].map(scopeTransform), Array.from(new Set(scopes));
}
function apiScopes(api, extraScopes = []) {
  let scopes = [...defaultApiScopes(api), ...extraScopes.map(scopeTransform)].map(scopeTransform);
  return Array.from(new Set(scopes));
}
function tokenExchangeScopes(api) {
  switch (api) {
    case "partners":
      return [scopeTransform("cli")];
    case "app-management":
      return [scopeTransform("app-management")];
    case "business-platform":
      return [scopeTransform("destinations")];
    default:
      throw new BugError(`API not supported for token exchange: ${api}`);
  }
}
function defaultApiScopes(api) {
  switch (api) {
    case "admin":
      return ["graphql", "themes", "collaborator"];
    case "storefront-renderer":
      return ["devtools"];
    case "partners":
      return ["cli"];
    case "business-platform":
      return ["destinations", "store-management", "on-demand-user-access"];
    case "app-management":
      return ["app-management"];
    default:
      throw new BugError(`Unknown API: ${api}`);
  }
}
function scopeTransform(scope) {
  switch (scope) {
    case "graphql":
      return "https://api.shopify.com/auth/shop.admin.graphql";
    case "themes":
      return "https://api.shopify.com/auth/shop.admin.themes";
    case "collaborator":
      return "https://api.shopify.com/auth/partners.collaborator-relationships.readonly";
    case "cli":
      return "https://api.shopify.com/auth/partners.app.cli.access";
    case "devtools":
      return "https://api.shopify.com/auth/shop.storefront-renderer.devtools";
    case "destinations":
      return "https://api.shopify.com/auth/destinations.readonly";
    case "store-management":
      return "https://api.shopify.com/auth/organization.store-management";
    case "on-demand-user-access":
      return "https://api.shopify.com/auth/organization.on-demand-user-access";
    case "app-management":
      return "https://api.shopify.com/auth/organization.apps.manage";
    default:
      return scope;
  }
}

// ../cli-kit/dist/private/node/session/exchange.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/fqdn.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/dev_server/index.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/dev_server/env.js
init_cjs_shims();
var isDevServerEnvironment = process.env.USING_DEV === "1" || process.env.SPIN === "1";
function assertCompatibleEnvironment() {
  if (!isDevServerEnvironment)
    throw new Error("DevServer is not supported in this environment");
}

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server.js
init_cjs_shims();
import fs5 from "node:fs";

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server-2024.js
init_cjs_shims();
var ni = __toESM(require_network_interfaces(), 1);
import fs2 from "node:fs";

// ../cli-kit/dist/public/node/vendor/dev_server/network/index.js
init_cjs_shims();
import { spawnSync } from "node:child_process";

// ../cli-kit/dist/public/node/vendor/dev_server/network/host.js
init_cjs_shims();
import fs from "node:fs";
var HOSTS_FILE = "/etc/hosts", hostToIpCache = {}, lastModifiedTime = 0;
function loadHostsFile() {
  try {
    let modifiedTime = fs.statSync(HOSTS_FILE).mtimeMs;
    if (modifiedTime === lastModifiedTime)
      return;
    let lines = fs.readFileSync(HOSTS_FILE, "utf8").split(/\r?\n/);
    hostToIpCache = {};
    for (let line of lines) {
      if (line.trim().startsWith("#") || line.trim() === "")
        continue;
      let matches = /^\s*(?<ipAddress>[^\s#]+)\s+(?<matchedHostName>[^\s#]+)\s*(#.*)?$/.exec(line);
      if (matches && matches.groups) {
        let { ipAddress, matchedHostName } = matches.groups;
        matchedHostName && ipAddress && (hostToIpCache[matchedHostName] = ipAddress);
      }
    }
    lastModifiedTime = modifiedTime;
  } catch (error) {
    console.log("Error reading hosts file:", error);
  }
}
function getIpFromHosts(hostname) {
  loadHostsFile();
  let ipAddress = hostToIpCache[hostname];
  if (ipAddress)
    return ipAddress;
  throw new Error(`No IP found for hostname: ${hostname}`);
}

// ../cli-kit/dist/public/node/vendor/dev_server/network/index.js
var DEFAULT_CONNECT_TIMEOUT = 100, checkPort;
function assertConnectable(options) {
  checkPort || (checkPort = getCheckPortHelper());
  let { port, addr, timeout = DEFAULT_CONNECT_TIMEOUT } = options;
  try {
    if (!checkPort(addr === "localhost" ? "127.0.0.1" : addr, port, timeout))
      throw new Error(`DevServer for '${options.projectName}' is not running on ${port} / ${addr}: \`dev up ${options.projectName}\` to start it.`);
  } catch (err2) {
    throw new Error(`DevServer check for '${options.projectName}' on ${port} / ${addr} failed (${err2})`);
  }
}
function getCheckPortHelper() {
  return fallbackCheckPort;
}
function fallbackCheckPort(address, port, timeout) {
  return spawnSync("nc", ["-z", "-w", "1", address, port.toString()], {
    timeout,
    stdio: "ignore"
  }).status === 0;
}

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server-2024.js
var NON_SHOP_PREFIXES = ["app", "dev", "shopify"], BACKEND_PORT = 8080;
function createServer(projectName) {
  return {
    host: (options = {}) => host(projectName, options),
    url: (options = {}) => url(projectName, options)
  };
}
function host(projectName, options = {}) {
  assertCompatibleEnvironment(), (assertRunningOverride || assertRunning2024)(projectName);
  let prefix = (options.nonstandardHostPrefix || projectName).replace(/_/g, "-");
  if (projectName === "shopify") {
    if (prefix.endsWith("-dev-api"))
      return `${prefix.replace("-dev-api", "")}.dev-api.shop.dev`;
    if (!NON_SHOP_PREFIXES.includes(prefix))
      return `${prefix}.my.shop.dev`;
  }
  return `${prefix}.shop.dev`;
}
function url(projectName, options = {}) {
  return `https://${host(projectName, options)}`;
}
function assertRunning2024(projectName) {
  assertConnectable({
    projectName,
    addr: getBackendIp(projectName),
    port: BACKEND_PORT
  });
}
function getBackendIp(projectName) {
  try {
    let backendIp = resolveBackendHost(projectName);
    return ni.fromIp(backendIp, { internal: !0, ipVersion: 4 }), backendIp;
  } catch {
    throw new Error(`DevServer for '${projectName}' is not running: \`dev up ${projectName}\` to start it.`);
  }
}
function resolveBackendHost(name) {
  let host4;
  try {
    host4 = fs2.readlinkSync(`/opt/nginx/etc/manifest/${name}/current`);
  } catch {
    host4 = `${name}.root.shopify.dev.internal`;
  }
  try {
    return getIpFromHosts(host4);
  } catch {
    return host4;
  }
}
var assertRunningOverride;

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server-2016.js
init_cjs_shims();
import fs3 from "fs";
import * as os from "node:os";
function createServer2(projectName) {
  return {
    host: (options = {}) => host2(projectName, options),
    url: (options = {}) => url2(projectName, options)
  };
}
function host2(projectName, options = {}) {
  return assertCompatibleEnvironment(), (assertRunningOverride2 || assertRunning2016)(projectName), `${options.nonstandardHostPrefix || projectName}.myshopify.io`;
}
function url2(projectName, options = {}) {
  return `https://${host2(projectName, options)}`;
}
function assertRunning2016(projectName) {
  let [addr, port] = getAddrPort(projectName);
  assertConnectable({ projectName, addr, port });
}
function getAddrPort(name) {
  try {
    let portContent = fs3.readFileSync(`${os.homedir()}/.local/run/services/${name}/server/port`, "utf-8");
    return ["localhost", parseInt(portContent, 10)];
  } catch {
    throw new Error(`DevServer for '${name}' is not running: \`dev up ${name}\` to start it.`);
  }
}
var assertRunningOverride2;

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server-spin.js
init_cjs_shims();
import fs4 from "node:fs";
function createServer3(projectName) {
  return {
    host: (options = {}) => host3(projectName, options),
    url: (options = {}) => url3(projectName, options)
  };
}
function host3(projectName, { nonstandardHostPrefix } = {}) {
  assertCompatibleEnvironment();
  let services = fs4.readdirSync("/run/ports2").filter((file) => file.endsWith(`--${projectName}`));
  if (services.length === 0)
    throw new Error(`DevServer for '${projectName}' not present in this spin environment`);
  if (projectName === "shopify")
    return `${nonstandardHostPrefix?.replace(/[-_]dev[-_]api$/, "")}.${projectName}.${process.env.SPIN_FQDN}`;
  let match = new RegExp(`^(.+)${projectName}$`).exec(services[0]), organization = match ? match[1] : "";
  return `${organization === "shopify--" ? "" : `${organization}`}${projectName}.${process.env.SPIN_FQDN}`;
}
function url3(projectName, options = {}) {
  return `https://${host3(projectName, options)}`;
}

// ../cli-kit/dist/public/node/vendor/dev_server/dev-server.js
var DevServer = class {
  constructor(projectName) {
    if (this.projectName = projectName, projectName === "shopify")
      throw new Error("Use `import {DevServerCore}` for the 'shopify' project");
    this.serverImpl = inferProjectServer(projectName);
  }
  host(options) {
    return this.serverImpl.host(options);
  }
  url(options) {
    return this.serverImpl.url(options);
  }
}, DevServerCore = class {
  constructor() {
    this.serverImpl = inferProjectServer("shopify");
  }
  host(prefix) {
    return this.serverImpl.host({ nonstandardHostPrefix: prefix });
  }
  url(prefix) {
    return this.serverImpl.url({ nonstandardHostPrefix: prefix });
  }
}, INFERENCE_MODE_SENTINEL = "/opt/dev/misc/dev-server-inference-mode";
function inferProjectServer(projectName) {
  return process.env.SPIN === "1" ? createServer3(projectName) : inferenceModeAndProjectIsEdition2016(projectName) ? createServer2(projectName) : createServer(projectName);
}
function inferenceModeAndProjectIsEdition2016(projectName) {
  try {
    fs5.accessSync(INFERENCE_MODE_SENTINEL);
    try {
      return fs5.accessSync(`/opt/nginx/etc/manifest/${projectName}/current/edition-2024`), !1;
    } catch {
      return !0;
    }
  } catch {
    return !1;
  }
}

// ../cli-kit/dist/public/node/context/fqdn.js
var CouldntObtainPartnersSpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Partners when the CLI is not running from a Spin environment."), CouldntObtainIdentitySpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Identity when the CLI is not running from a Spin environment."), CouldntObtainShopifySpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Shopify when the CLI is not running from a Spin environment."), NotProvidedStoreFQDNError = new AbortError("Couldn't obtain the Shopify FQDN because the store FQDN was not provided.");
async function partnersFqdn() {
  if (blockPartnersAccess())
    throw new BugError("Partners API is blocked by the SHOPIFY_CLI_NEVER_USE_PARTNERS_API environment variable.");
  let environment = serviceEnvironment(), productionFqdn = "partners.shopify.com";
  switch (environment) {
    case "local":
      return new DevServer("partners").host();
    case "spin":
      return `partners.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function adminFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "admin.shopify.com";
  switch (environment) {
    case "local":
      return new DevServerCore().host("admin");
    case "spin":
      return `admin.shopify.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function appManagementFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "app.shopify.com";
  switch (environment) {
    case "local":
      return new DevServerCore().host("app");
    case "spin":
      return `app.shopify.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function appDevFqdn(storeFqdn) {
  switch (serviceEnvironment()) {
    case "local":
      return new DevServerCore().host("app");
    default:
      return storeFqdn;
  }
}
async function developerDashboardFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "dev.shopify.com";
  switch (environment) {
    case "local":
      return new DevServerCore().host("dev");
    case "spin":
      return `dev.shopify.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function businessPlatformFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "destinations.shopifysvc.com";
  switch (environment) {
    case "local":
      return new DevServer("business-platform").host();
    case "spin":
      return `business-platform.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function identityFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "accounts.shopify.com";
  switch (environment) {
    case "local":
      return new DevServer("identity").host();
    case "spin":
      return `identity.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function normalizeStoreFqdn(store2) {
  let storeFqdn = store2.replace(/^https?:\/\//, "").replace(/\/$/, ""), addDomain = async (storeFqdn2) => {
    switch (serviceEnvironment()) {
      case "local":
        return new DevServerCore().host(storeFqdn2);
      case "spin":
        return `${storeFqdn2}.shopify.${await spinFqdn()}`;
      default:
        return `${storeFqdn2}.myshopify.com`;
    }
  };
  return ((storeFqdn2) => storeFqdn2.includes(".myshopify.com") || storeFqdn2.includes("spin.dev") || storeFqdn2.includes("shopify.io") || storeFqdn2.includes(".shop.dev"))(storeFqdn) ? storeFqdn : addDomain(storeFqdn);
}

// ../cli-kit/dist/public/node/result.js
init_cjs_shims();
var ok = (value) => new Ok(value), err = (err2) => new Err(err2), Ok = class {
  constructor(value) {
    this.value = value;
  }
  /**
   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`
   *
   * @returns `false` as the `Resul` is `OK`
   */
  isErr() {
    return !1;
  }
  /**
   * Runs the `handler` method an return the same an unaltered copy of the `Result`. It could be used to log an
   * output when the result is `Ok` without breaking the flow
   *
   * @param handler - method to be run when the result is `Ok`
   * @returns a copy of the same `Result`
   */
  doOnOk(handler) {
    return handler(this.value), ok(this.value);
  }
  /**
   * A safe mode to throw the `error` of the `Result`
   */
  valueOrBug() {
    return this.value;
  }
  /**
   * Throws an abort error if the result doesn't represent a value.
   */
  valueOrAbort() {
    return this.value;
  }
  /**
   * Maps the value to another one with a different type. It leaves the `Error` type unaltered
   *
   * @param mapper - The mapper method to apply an `OK` value
   * @returns a new result with the new mapped value
   */
  map(mapper) {
    return ok(mapper(this.value));
  }
  /**
   * Maps the error type to another one. It leaves the `Ok` type and value unaltered
   *
   * @param _mapper - This mapper method is not used for an `Ok` value
   * @returns a new result with the new mapped error type and an value
   */
  mapError(_mapper) {
    return ok(this.value);
  }
}, Err = class {
  // eslint-disable-next-line node/handle-callback-err
  constructor(error) {
    this.error = error;
  }
  /**
   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`
   *
   * @returns `false` as the `Resul` is `OK`
   */
  isErr() {
    return !0;
  }
  /**
   * Return an unaltered copy of the `Error` without doing anything.
   *
   * @param _handler - This handler method is not used for an `Error`
   * @returns a copy of the same `Error`
   */
  doOnOk(_handler) {
    return err(this.error);
  }
  /**
   * A safe mode to throw the `error` of the `Result`
   */
  valueOrBug() {
    throw this.error;
  }
  /**
   * Throws an abort error if the result doesn't represent a value.
   */
  valueOrAbort() {
    if (this.error instanceof FatalError)
      throw this.error;
    if (this.error instanceof import_ts_error.ExtendableError || this.error instanceof Error) {
      let error = new AbortError(this.error.message);
      throw error.stack = this.error.stack, error;
    } else
      throw new AbortError(`${this.error}`);
  }
  /**
   * Maps the value type to another one. It leaves the `Error` unaltered
   *
   * @param _mapper - This mapper method is not used for an `Error` value
   * @returns a new result with the new value type and an unaltered error
   */
  map(_mapper) {
    return err(this.error);
  }
  /**
   * Maps the error to another one with a different type. It leaves the value type unaltered
   *
   * @param mapper - The mapper method to apply an `Error` value
   * @returns a new result with the new mapped error
   */
  mapError(mapper) {
    return err(mapper(this.error));
  }
};

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/runtime/base64url.js
init_cjs_shims();
import { Buffer } from "node:buffer";

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/buffer_utils.js
init_cjs_shims();
var encoder = new TextEncoder(), decoder = new TextDecoder(), MAX_INT32 = 2 ** 32;

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/runtime/base64url.js
function normalize(input) {
  let encoded = input;
  return encoded instanceof Uint8Array && (encoded = decoder.decode(encoded)), encoded;
}
var decode = (input) => new Uint8Array(Buffer.from(normalize(input), "base64url"));

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/errors.js
init_cjs_shims();
var JOSEError = class extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message, options) {
    super(message, options), this.name = this.constructor.name, Error.captureStackTrace?.(this, this.constructor);
  }
};
var JWTInvalid = class extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
};

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/is_object.js
init_cjs_shims();
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(input) === null)
    return !0;
  let proto = input;
  for (; Object.getPrototypeOf(proto) !== null; )
    proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(input) === proto;
}

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/base64url.js
init_cjs_shims();
var decode2 = decode;

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/decode_jwt.js
init_cjs_shims();
function decodeJwt(jwt) {
  if (typeof jwt != "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  let { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// ../cli-kit/dist/private/node/session/exchange.js
var InvalidGrantError = class extends import_ts_error.ExtendableError {
}, InvalidRequestError = class extends import_ts_error.ExtendableError {
}, InvalidTargetError = class extends AbortError {
};
async function exchangeAccessForApplicationTokens(identityToken, scopes, store2) {
  let token = identityToken.accessToken, [partners, storefront, businessPlatform, admin, appManagement] = await Promise.all([
    requestAppToken("partners", token, scopes.partners),
    requestAppToken("storefront-renderer", token, scopes.storefront),
    requestAppToken("business-platform", token, scopes.businessPlatform),
    store2 ? requestAppToken("admin", token, scopes.admin, store2) : {},
    requestAppToken("app-management", token, scopes.appManagement)
  ]);
  return {
    ...partners,
    ...storefront,
    ...businessPlatform,
    ...admin,
    ...appManagement
  };
}
async function refreshAccessToken(currentToken) {
  let clientId2 = clientId(), params = {
    grant_type: "refresh_token",
    access_token: currentToken.accessToken,
    refresh_token: currentToken.refreshToken,
    client_id: clientId2
  }, value = (await tokenRequest(params)).mapError(tokenRequestErrorHandler).valueOrBug();
  return buildIdentityToken(value, currentToken.userId);
}
async function exchangeCliTokenForAccessToken(apiName, token, scopes) {
  let appId = applicationId(apiName);
  try {
    let accessToken = (await requestAppToken(apiName, token, scopes))[appId].accessToken, userId2 = nonRandomUUID(token);
    return setLastSeenUserIdAfterAuth(userId2), setLastSeenAuthMethod("partners_token"), { accessToken, userId: userId2 };
  } catch {
    let prettyName = apiName.replace(/-/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
    throw new AbortError(`The custom token provided can't be used for the ${prettyName} API.`, "Ensure the token is correct and not expired.");
  }
}
async function exchangeCustomPartnerToken(token) {
  return exchangeCliTokenForAccessToken("partners", token, tokenExchangeScopes("partners"));
}
async function exchangeCliTokenForAppManagementAccessToken(token) {
  return exchangeCliTokenForAccessToken("app-management", token, tokenExchangeScopes("app-management"));
}
async function exchangeCliTokenForBusinessPlatformAccessToken(token) {
  return exchangeCliTokenForAccessToken("business-platform", token, tokenExchangeScopes("business-platform"));
}
async function exchangeDeviceCodeForAccessToken(deviceCode) {
  let clientId2 = await clientId(), tokenResult = await tokenRequest({
    grant_type: "urn:ietf:params:oauth:grant-type:device_code",
    device_code: deviceCode,
    client_id: clientId2
  });
  if (tokenResult.isErr())
    return err(tokenResult.error.error);
  let identityToken = buildIdentityToken(tokenResult.value);
  return ok(identityToken);
}
async function requestAppToken(api, token, scopes = [], store2) {
  let appId = applicationId(api), params = {
    grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
    requested_token_type: "urn:ietf:params:oauth:token-type:access_token",
    subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
    client_id: await clientId(),
    audience: appId,
    scope: scopes.join(" "),
    subject_token: token,
    ...api === "admin" && { destination: `https://${store2}/admin`, store: store2 }
  }, identifier = appId;
  api === "admin" && store2 && (identifier = `${store2}-${appId}`);
  let value = (await tokenRequest(params)).mapError(tokenRequestErrorHandler).valueOrBug(), appToken = buildApplicationToken(value);
  return { [identifier]: appToken };
}
function tokenRequestErrorHandler({ error, store: store2 }) {
  let invalidTargetErrorMessage = `You are not authorized to use the CLI to develop in the provided store${store2 ? `: ${store2}` : "."}

You can't use Shopify CLI with development stores if you only have Partner staff member access. If you want to use Shopify CLI to work on a development store, then you should be the store owner or create a staff account on the store.

If you're the store owner, then you need to log in to the store directly using the store URL at least once before you log in using Shopify CLI. Logging in to the Shopify admin directly connects the development store with your Shopify login.`;
  return error === "invalid_grant" ? new InvalidGrantError() : error === "invalid_request" ? new InvalidRequestError() : error === "invalid_target" ? new InvalidTargetError(invalidTargetErrorMessage) : new AbortError(error);
}
async function tokenRequest(params) {
  let fqdn = await identityFqdn(), url4 = new URL(`https://${fqdn}/oauth/token`);
  url4.search = new URLSearchParams(Object.entries(params)).toString();
  let res = await shopifyFetch(url4.href, { method: "POST" }), payload = await res.json();
  return res.ok ? ok(payload) : err({ error: payload.error, store: params.store });
}
function buildIdentityToken(result, existingUserId) {
  let userId2 = existingUserId ?? (result.id_token ? decodeJwt(result.id_token).sub : void 0);
  if (!userId2)
    throw new BugError("Error setting userId for session. No id_token or pre-existing user ID provided.");
  return {
    accessToken: result.access_token,
    refreshToken: result.refresh_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" "),
    userId: userId2
  };
}
function buildApplicationToken(result) {
  return {
    accessToken: result.access_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" ")
  };
}

// ../cli-kit/dist/private/node/session/store.js
init_cjs_shims();
async function store(session) {
  let jsonSession = JSON.stringify(session);
  setSession(jsonSession);
}
async function fetch() {
  let content = getSession();
  if (!content)
    return;
  let contentJson = JSON.parse(content), parsedSession = await SessionSchema.safeParseAsync(contentJson);
  if (parsedSession.success)
    return parsedSession.data;
  await remove();
}
async function remove() {
  removeSession();
}

// ../cli-kit/dist/private/node/session/device-authorization.js
init_cjs_shims();
async function requestDeviceAuthorization(scopes) {
  let fqdn = await identityFqdn(), queryParams = { client_id: clientId(), scope: scopes.join(" ") }, url4 = `https://${fqdn}/oauth/device_authorization`, response = await shopifyFetch(url4, {
    method: "POST",
    headers: { "Content-type": "application/x-www-form-urlencoded" },
    body: convertRequestToParams(queryParams)
  }), jsonResult;
  try {
    jsonResult = await response.json();
  } catch {
    throw new BugError("Received unexpected response from the authorization service. If this issue persists, please contact support at https://help.shopify.com");
  }
  if (outputDebug(outputContent`Received device authorization code: ${outputToken.json(jsonResult)}`), !jsonResult.device_code || !jsonResult.verification_uri_complete)
    throw new BugError("Failed to start authorization process");
  if (outputInfo(`
To run this command, log in to Shopify.`), isCI())
    throw new AbortError("Authorization is required to continue, but the current environment does not support interactive prompts.", "To resolve this, specify credentials in your environment, or run the command in an interactive environment such as your local terminal.");
  outputInfo(outputContent`User verification code: ${jsonResult.user_code}`);
  let linkToken = outputToken.link(jsonResult.verification_uri_complete), cloudMessage = () => {
    outputInfo(outputContent`👉 Open this link to start the auth process: ${linkToken}`);
  };
  return isCloudEnvironment() || !isTTY() ? cloudMessage() : (outputInfo("\u{1F449} Press any key to open the login page on your browser"), await keypress(), await openURL(jsonResult.verification_uri_complete) ? outputInfo(outputContent`Opened link to start the auth process: ${linkToken}`) : cloudMessage()), {
    deviceCode: jsonResult.device_code,
    userCode: jsonResult.user_code,
    verificationUri: jsonResult.verification_uri,
    expiresIn: jsonResult.expires_in,
    verificationUriComplete: jsonResult.verification_uri_complete,
    interval: jsonResult.interval
  };
}
async function pollForDeviceAuthorization(code, interval = 5) {
  let currentIntervalInSeconds = interval;
  return new Promise((resolve, reject) => {
    let onPoll = async () => {
      let result = await exchangeDeviceCodeForAccessToken(code);
      if (!result.isErr()) {
        resolve(result.value);
        return;
      }
      let error = result.error ?? "unknown_failure";
      switch (outputDebug(outputContent`Polling for device authorization... status: ${error}`), error) {
        case "authorization_pending": {
          startPolling();
          return;
        }
        case "slow_down":
          currentIntervalInSeconds += 5;
          {
            startPolling();
            return;
          }
        case "access_denied":
        case "expired_token":
        case "unknown_failure":
          reject(result);
      }
    }, startPolling = () => {
      setTimeout(onPoll, currentIntervalInSeconds * 1e3);
    };
    startPolling();
  });
}
function convertRequestToParams(queryParams) {
  return Object.entries(queryParams).map(([key, value]) => value && `${key}=${value}`).filter((hasValue) => !!hasValue).join("&");
}

// ../cli-kit/dist/private/node/api/rest.js
init_cjs_shims();
function isThemeAccessSession(session) {
  return session.token.startsWith("shptka_");
}

// ../cli-kit/dist/private/node/session.js
var userId, authMethod = "none";
async function getLastSeenUserIdAfterAuth() {
  if (userId)
    return userId;
  let currentSession = await fetch() || {}, fqdn = await identityFqdn(), cachedUserId = currentSession[fqdn]?.identity.userId;
  if (cachedUserId)
    return cachedUserId;
  let customToken = getPartnersToken() ?? themeToken();
  return customToken ? nonRandomUUID(customToken) : "unknown";
}
function setLastSeenUserIdAfterAuth(id) {
  userId = id;
}
async function getLastSeenAuthMethod() {
  if (authMethod !== "none")
    return authMethod;
  let currentSession = await fetch() || {}, fqdn = await identityFqdn();
  if (currentSession[fqdn]?.identity.userId)
    return "device_auth";
  if (getPartnersToken())
    return "partners_token";
  let themePassword = themeToken();
  return themePassword ? isThemeAccessSession({ token: themePassword, storeFqdn: "" }) ? "theme_access_token" : "custom_app_token" : "none";
}
function setLastSeenAuthMethod(method) {
  authMethod = method;
}
async function ensureAuthenticated(applications, _env, { forceRefresh = !1, noPrompt = !1 } = {}) {
  let fqdn = await identityFqdn(), previousStoreFqdn = applications.adminApi?.storeFqdn;
  if (previousStoreFqdn) {
    let normalizedStoreName = await normalizeStoreFqdn(previousStoreFqdn);
    previousStoreFqdn === applications.adminApi?.storeFqdn && (applications.adminApi.storeFqdn = normalizedStoreName);
  }
  let currentSession = await fetch() || {}, fqdnSession = currentSession[fqdn], scopes = getFlattenScopes(applications);
  outputDebug(outputContent`Validating existing session against the scopes:
${outputToken.json(scopes)}
For applications:
${outputToken.json(applications)}
`);
  let validationResult = await validateSession(scopes, applications, fqdnSession), newSession = {};
  function throwOnNoPrompt() {
    if (!(!noPrompt || isSpin() && firstPartyDev()))
      throw new AbortError(`The currently available CLI credentials are invalid.

The CLI is currently unable to prompt for reauthentication.`, "Restart the CLI process you were running. If in an interactive terminal, you will be prompted to reauthenticate. If in a non-interactive terminal, ensure the correct credentials are available in the program environment.");
  }
  if (validationResult === "needs_full_auth")
    throwOnNoPrompt(), outputDebug(outputContent`Initiating the full authentication flow...`), newSession = await executeCompleteFlow(applications, fqdn);
  else if (validationResult === "needs_refresh" || forceRefresh) {
    outputDebug(outputContent`The current session is valid but needs refresh. Refreshing...`);
    try {
      newSession = await refreshTokens(fqdnSession.identity, applications, fqdn);
    } catch (error) {
      if (error instanceof InvalidGrantError)
        throwOnNoPrompt(), newSession = await executeCompleteFlow(applications, fqdn);
      else throw error instanceof InvalidRequestError ? (await remove(), new AbortError(`
Error validating auth session`, "We've cleared the current session, please try again")) : error;
    }
  }
  let completeSession = { ...currentSession, ...newSession };
  Object.keys(newSession).length > 0 && await store(completeSession);
  let tokens = await tokensFor(applications, completeSession, fqdn), envToken = getPartnersToken();
  return envToken && applications.partnersApi && (tokens.partners = (await exchangeCustomPartnerToken(envToken)).accessToken), setLastSeenAuthMethod(envToken ? "partners_token" : "device_auth"), setLastSeenUserIdAfterAuth(tokens.userId), tokens;
}
async function executeCompleteFlow(applications, identityFqdn2) {
  let scopes = getFlattenScopes(applications), exchangeScopes = getExchangeScopes(applications), store2 = applications.adminApi?.storeFqdn;
  firstPartyDev() && (outputDebug(outputContent`Authenticating as Shopify Employee...`), scopes.push("employee"));
  let identityToken, identityTokenInformation = getIdentityTokenInformation();
  if (identityTokenInformation)
    identityToken = buildIdentityTokenFromEnv(scopes, identityTokenInformation);
  else {
    outputDebug(outputContent`Requesting device authorization code...`);
    let deviceAuth = await requestDeviceAuthorization(scopes);
    outputDebug(outputContent`Starting polling for the identity token...`), identityToken = await pollForDeviceAuthorization(deviceAuth.deviceCode, deviceAuth.interval);
  }
  outputDebug(outputContent`CLI token received. Exchanging it for application tokens...`);
  let result = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, store2), session = {
    [identityFqdn2]: {
      identity: identityToken,
      applications: result
    }
  };
  return outputCompleted("Logged in."), session;
}
async function refreshTokens(token, applications, fqdn) {
  let identityToken = await refreshAccessToken(token), exchangeScopes = getExchangeScopes(applications), applicationTokens = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, applications.adminApi?.storeFqdn);
  return {
    [fqdn]: {
      identity: identityToken,
      applications: applicationTokens
    }
  };
}
async function tokensFor(applications, session, fqdn) {
  let fqdnSession = session[fqdn];
  if (!fqdnSession)
    throw new BugError("No session found after ensuring authenticated");
  let tokens = {
    userId: fqdnSession.identity.userId
  };
  if (applications.adminApi) {
    let appId = applicationId("admin"), realAppId = `${applications.adminApi.storeFqdn}-${appId}`, token = fqdnSession.applications[realAppId]?.accessToken;
    token && (tokens.admin = { token, storeFqdn: applications.adminApi.storeFqdn });
  }
  if (applications.partnersApi) {
    let appId = applicationId("partners");
    tokens.partners = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.storefrontRendererApi) {
    let appId = applicationId("storefront-renderer");
    tokens.storefront = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.businessPlatformApi) {
    let appId = applicationId("business-platform");
    tokens.businessPlatform = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.appManagementApi) {
    let appId = applicationId("app-management");
    tokens.appManagement = fqdnSession.applications[appId]?.accessToken;
  }
  return tokens;
}
function getFlattenScopes(apps) {
  let admin = apps.adminApi?.scopes || [], partner = apps.partnersApi?.scopes || [], storefront = apps.storefrontRendererApi?.scopes || [], businessPlatform = apps.businessPlatformApi?.scopes || [], appManagement = apps.appManagementApi?.scopes || [], requestedScopes = [...admin, ...partner, ...storefront, ...businessPlatform, ...appManagement];
  return allDefaultScopes(requestedScopes);
}
function getExchangeScopes(apps) {
  let adminScope = apps.adminApi?.scopes || [], partnerScope = apps.partnersApi?.scopes || [], storefrontScopes = apps.storefrontRendererApi?.scopes || [], businessPlatformScopes = apps.businessPlatformApi?.scopes || [], appManagementScopes = apps.appManagementApi?.scopes || [];
  return {
    admin: apiScopes("admin", adminScope),
    partners: apiScopes("partners", partnerScope),
    storefront: apiScopes("storefront-renderer", storefrontScopes),
    businessPlatform: apiScopes("business-platform", businessPlatformScopes),
    appManagement: apiScopes("app-management", appManagementScopes)
  };
}
function buildIdentityTokenFromEnv(scopes, identityTokenInformation) {
  return {
    ...identityTokenInformation,
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
    scopes
  };
}

// ../cli-kit/dist/private/node/analytics.js
async function startAnalytics({ commandContent, args, currentTime = (/* @__PURE__ */ new Date()).getTime(), commandClass }) {
  let startCommand = commandContent.command;
  commandClass && Object.prototype.hasOwnProperty.call(commandClass, "analyticsNameOverride") && (startCommand = commandClass.analyticsNameOverride() ?? commandContent.command);
  let pluginName = commandClass?.plugin?.name;
  commandClass && "customPluginName" in commandClass && (pluginName = commandClass.customPluginName), await addSensitiveMetadata(() => ({
    commandStartOptions: {
      startTime: currentTime,
      startCommand,
      startArgs: args
    }
  })), await addPublicMetadata(() => ({
    cmd_all_launcher: packageManagerFromUserAgent(),
    cmd_all_alias_used: commandContent.alias,
    cmd_all_topic: commandContent.topic,
    cmd_all_plugin: pluginName,
    cmd_all_force: flagIncluded("force", commandClass) ? args.includes("--force") : void 0
  }));
}
async function getEnvironmentData(config) {
  let ciplatform = ciPlatform(), pluginNames = getPluginNames(config), shopifyPlugins = pluginNames.filter((plugin) => plugin.startsWith("@shopify/")), { platform, arch } = platformAndArch();
  return {
    uname: `${platform} ${arch}`,
    env_ci: ciplatform.isCI,
    env_ci_platform: ciplatform.name,
    env_plugin_installed_any_custom: pluginNames.length !== shopifyPlugins.length,
    env_plugin_installed_shopify: JSON.stringify(shopifyPlugins),
    env_shell: config.shell,
    env_web_ide: cloudEnvironment().editor ? cloudEnvironment().platform : void 0,
    env_device_id: hashString(await macAddress()),
    env_cloud: cloudEnvironment().platform,
    env_package_manager: await getPackageManager(cwd()),
    env_is_global: currentProcessIsGlobal(),
    env_auth_method: await getLastSeenAuthMethod(),
    env_is_wsl: await isWsl()
  };
}
async function getSensitiveEnvironmentData(config) {
  return {
    env_plugin_installed_all: JSON.stringify(getPluginNames(config))
  };
}
function getPluginNames(config) {
  return [...config.plugins.keys()].sort().filter((plugin) => !plugin.startsWith("@oclif/"));
}
function flagIncluded(flag, commandClass) {
  if (!commandClass)
    return !1;
  let commandFlags = commandClass.flags ?? {};
  return Object.keys(commandFlags).includes(flag);
}

export {
  partnersFqdn,
  adminFqdn,
  appManagementFqdn,
  appDevFqdn,
  developerDashboardFqdn,
  businessPlatformFqdn,
  normalizeStoreFqdn,
  ok,
  err,
  exchangeCustomPartnerToken,
  exchangeCliTokenForAppManagementAccessToken,
  exchangeCliTokenForBusinessPlatformAccessToken,
  remove,
  isThemeAccessSession,
  getLastSeenUserIdAfterAuth,
  setLastSeenUserIdAfterAuth,
  setLastSeenAuthMethod,
  ensureAuthenticated,
  startAnalytics,
  getEnvironmentData,
  getSensitiveEnvironmentData
};
//# sourceMappingURL=chunk-JLJTVUDK.js.map
