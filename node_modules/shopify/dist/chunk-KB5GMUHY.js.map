{
  "version": 3,
  "sources": ["../../cli-kit/src/public/node/notifications-system.ts", "../../cli-kit/src/public/node/global-context.ts"],
  "sourcesContent": ["import {versionSatisfies} from './node-package-manager.js'\nimport {renderError, renderInfo, renderWarning} from './ui.js'\nimport {getCurrentCommandId} from './global-context.js'\nimport {outputDebug} from './output.js'\nimport {zod} from './schema.js'\nimport {AbortSilentError} from './error.js'\nimport {isTruthy} from './context/utilities.js'\nimport {exec} from './system.js'\nimport {jsonOutputEnabled} from './environment.js'\nimport {fetch} from './http.js'\nimport {CLI_KIT_VERSION} from '../common/version.js'\nimport {NotificationKey, NotificationsKey, cacheRetrieve, cacheStore} from '../../private/node/conf-store.js'\n\nconst URL = 'https://cdn.shopify.com/static/cli/notifications.json'\nconst EMPTY_CACHE_MESSAGE = 'Cache is empty'\nconst COMMANDS_TO_SKIP = [\n  'notifications:list',\n  'notifications:generate',\n  'init',\n  'app:init',\n  'theme:init',\n  'hydrogen:init',\n  'cache:clear',\n]\n\nfunction url(): string {\n  return process.env.SHOPIFY_CLI_NOTIFICATIONS_URL ?? URL\n}\n\nconst NotificationSchema = zod.object({\n  id: zod.string(),\n  message: zod.string(),\n  type: zod.enum(['info', 'warning', 'error']),\n  frequency: zod.enum(['always', 'once', 'once_a_day', 'once_a_week']),\n  ownerChannel: zod.string(),\n  cta: zod\n    .object({\n      label: zod.string(),\n      url: zod.string().url(),\n    })\n    .optional(),\n  title: zod.string().optional(),\n  minVersion: zod.string().optional(),\n  maxVersion: zod.string().optional(),\n  minDate: zod.string().optional(),\n  maxDate: zod.string().optional(),\n  commands: zod.array(zod.string()).optional(),\n  surface: zod.string().optional(),\n})\nexport type Notification = zod.infer<typeof NotificationSchema>\n\nconst NotificationsSchema = zod.object({notifications: zod.array(NotificationSchema)})\nexport type Notifications = zod.infer<typeof NotificationsSchema>\n\n/**\n * Shows notifications to the user if they meet the criteria specified in the notifications.json file.\n *\n * @param currentSurfaces - The surfaces present in the current project (usually for app extensions).\n * @param environment - Process environment variables.\n * @returns - A promise that resolves when the notifications have been shown.\n */\nexport async function showNotificationsIfNeeded(\n  currentSurfaces?: string[],\n  environment: NodeJS.ProcessEnv = process.env,\n): Promise<void> {\n  try {\n    const commandId = getCurrentCommandId()\n    if (skipNotifications(commandId, environment) || jsonOutputEnabled(environment)) return\n\n    const notifications = await getNotifications()\n    const notificationsToShow = filterNotifications(notifications.notifications, commandId, currentSurfaces)\n    outputDebug(`Notifications to show: ${notificationsToShow.length}`)\n    await renderNotifications(notificationsToShow)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (error: any) {\n    if (error.message === EMPTY_CACHE_MESSAGE) {\n      outputDebug('Notifications to show: 0 (Cache is empty)')\n      return\n    }\n    if (error.message === 'abort') throw new AbortSilentError()\n    const errorMessage = `Error showing notifications: ${error.message}`\n    outputDebug(errorMessage)\n    // This is very prone to becoming a circular dependency, so we import it dynamically\n    const {sendErrorToBugsnag} = await import('./error-handler.js')\n    await sendErrorToBugsnag(errorMessage, 'unexpected_error')\n  }\n}\n\nfunction skipNotifications(currentCommand: string, environment: NodeJS.ProcessEnv = process.env): boolean {\n  return (\n    isTruthy(environment.CI) || isTruthy(environment.SHOPIFY_UNIT_TEST) || COMMANDS_TO_SKIP.includes(currentCommand)\n  )\n}\n\n/**\n * Renders the first 2 notifications to the user.\n *\n * @param notifications - The notifications to render.\n */\nasync function renderNotifications(notifications: Notification[]) {\n  notifications.slice(0, 2).forEach((notification) => {\n    const content = {\n      headline: notification.title,\n      body: notification.message.replaceAll('\\\\n', '\\n'),\n      link: notification.cta,\n    }\n    switch (notification.type) {\n      case 'info': {\n        renderInfo(content)\n        break\n      }\n      case 'warning': {\n        renderWarning(content)\n        break\n      }\n      case 'error': {\n        renderError(content)\n        throw new Error('abort')\n      }\n    }\n    cacheStore(`notification-${notification.id}`, new Date().getTime().toString())\n  })\n}\n\n/**\n * Get notifications list from cache, that is updated in the background from bin/fetch-notifications.json.\n *\n * @returns A Notifications object.\n */\nexport async function getNotifications(): Promise<Notifications> {\n  const cacheKey: NotificationsKey = `notifications-${url()}`\n  const rawNotifications = cacheRetrieve(cacheKey)?.value as unknown as string\n  if (!rawNotifications) throw new Error(EMPTY_CACHE_MESSAGE)\n  const notifications: object = JSON.parse(rawNotifications)\n  return NotificationsSchema.parse(notifications)\n}\n\n/**\n * Fetch notifications from the CDN and chache them.\n *\n * @returns A string with the notifications.\n */\nexport async function fetchNotifications(): Promise<Notifications> {\n  outputDebug(`Fetching notifications...`)\n  const response = await fetch(url(), undefined, {\n    useNetworkLevelRetry: false,\n    useAbortSignal: true,\n    timeoutMs: 3 * 1000,\n  })\n  if (response.status !== 200) throw new Error(`Failed to fetch notifications: ${response.statusText}`)\n  const rawNotifications = await response.text()\n  const notifications: object = JSON.parse(rawNotifications)\n  const result = NotificationsSchema.parse(notifications)\n  await cacheNotifications(rawNotifications)\n  return result\n}\n\n/**\n * Store the notifications in the cache.\n *\n * @param notifications - String with the notifications to cache.\n * @returns A Notifications object.\n */\nasync function cacheNotifications(notifications: string): Promise<void> {\n  cacheStore(`notifications-${url()}`, notifications)\n  outputDebug(`Notifications from ${url()} stored in the cache`)\n}\n\n/**\n * Fetch notifications in background as a detached process.\n *\n * @param currentCommand - The current Shopify command being run.\n * @param argv - The arguments passed to the current process.\n * @param environment - Process environment variables.\n */\nexport function fetchNotificationsInBackground(\n  currentCommand: string,\n  argv = process.argv,\n  environment: NodeJS.ProcessEnv = process.env,\n): void {\n  if (skipNotifications(currentCommand, environment)) return\n  if (!argv[0] || !argv[1]) return\n\n  // Run the Shopify command the same way as the current execution\n  const nodeBinary = argv[0]\n  const shopifyBinary = argv[1]\n  const args = [shopifyBinary, 'notifications', 'list', '--ignore-errors']\n\n  // eslint-disable-next-line no-void\n  void exec(nodeBinary, args, {\n    background: true,\n    env: {...process.env, SHOPIFY_CLI_NO_ANALYTICS: '1'},\n    externalErrorHandler: async (error: unknown) => {\n      outputDebug(`Failed to fetch notifications in background: ${(error as Error).message}`)\n    },\n  })\n}\n\n/**\n * Filters notifications based on the version of the CLI.\n *\n * @param notifications - The notifications to filter.\n * @param commandId - The command ID to filter by.\n * @param currentSurfaces - The surfaces present in the current project (usually for app extensions).\n * @param today - The current date.\n * @param currentVersion - The current version of the CLI.\n * @returns - The filtered notifications.\n */\nexport function filterNotifications(\n  notifications: Notification[],\n  commandId: string,\n  currentSurfaces?: string[],\n  today: Date = new Date(new Date().setUTCHours(0, 0, 0, 0)),\n  currentVersion: string = CLI_KIT_VERSION,\n): Notification[] {\n  return notifications\n    .filter((notification) => filterByVersion(notification, currentVersion))\n    .filter((notifications) => filterByDate(notifications, today))\n    .filter((notification) => filterByCommand(notification, commandId))\n    .filter((notification) => filterBySurface(notification, commandId, currentSurfaces))\n    .filter((notification) => filterByFrequency(notification))\n}\n\n/**\n * Filters notifications based on the version of the CLI.\n *\n * @param notification - The notification to filter.\n * @param currentVersion - The current version of the CLI.\n */\nfunction filterByVersion(notification: Notification, currentVersion: string) {\n  const minVersion = !notification.minVersion || versionSatisfies(currentVersion, `>=${notification.minVersion}`)\n  const maxVersion = !notification.maxVersion || versionSatisfies(currentVersion, `<=${notification.maxVersion}`)\n  return minVersion && maxVersion\n}\n\n/**\n * Filters notifications based on the date.\n *\n * @param notification - The notification to filter.\n * @param today - The current date.\n */\nfunction filterByDate(notification: Notification, today: Date) {\n  const minDate = !notification.minDate || new Date(notification.minDate) <= today\n  const maxDate = !notification.maxDate || new Date(notification.maxDate) >= today\n  return minDate && maxDate\n}\n\n/**\n * Filters notifications based on the command ID.\n *\n * @param notification - The notification to filter.\n * @param commandId - The command ID to filter by.\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterByCommand(notification: Notification, commandId: string) {\n  if (commandId === '') return true\n  return !notification.commands || notification.commands.includes(commandId)\n}\n\n/**\n * Filters notifications based on the surface.\n *\n * @param notification - The notification to filter.\n * @param commandId - The command id.\n * @param surfacesFromContext - The surfaces present in the current project (usually for app extensions).\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterBySurface(notification: Notification, commandId: string, surfacesFromContext?: string[]) {\n  const surfaceFromCommand = commandId.split(':')[0] ?? 'all'\n  const notificationSurface = notification.surface ?? 'all'\n\n  if (surfacesFromContext) return surfacesFromContext.includes(notificationSurface)\n\n  return notificationSurface === surfaceFromCommand || notificationSurface === 'all'\n}\n\n/**\n * Filters notifications based on the frequency.\n *\n * @param notification - The notification to filter.\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterByFrequency(notification: Notification): boolean {\n  if (!notification.frequency) return true\n  const cacheKey: NotificationKey = `notification-${notification.id}`\n  const lastShown = cacheRetrieve(cacheKey)?.value as unknown as string\n  if (!lastShown) return true\n\n  switch (notification.frequency) {\n    case 'always': {\n      return true\n    }\n    case 'once': {\n      return false\n    }\n    case 'once_a_day': {\n      return new Date().getTime() - Number(lastShown) > 24 * 3600 * 1000\n    }\n    case 'once_a_week': {\n      return new Date().getTime() - Number(lastShown) > 7 * 24 * 3600 * 1000\n    }\n  }\n}\n\n/**\n * Returns a string with the filters from a notification, one by line.\n *\n * @param notification - The notification to get the filters from.\n * @returns A string with human-readable filters from the notification.\n */\nexport function stringifyFilters(notification: Notification): string {\n  const filters = []\n  if (notification.minDate) filters.push(`from ${notification.minDate}`)\n  if (notification.maxDate) filters.push(`to ${notification.maxDate}`)\n  if (notification.minVersion) filters.push(`from v${notification.minVersion}`)\n  if (notification.maxVersion) filters.push(`to v${notification.maxVersion}`)\n  if (notification.frequency === 'once') filters.push('show only once')\n  if (notification.frequency === 'once_a_day') filters.push('show once a day')\n  if (notification.frequency === 'once_a_week') filters.push('show once a week')\n  if (notification.surface) filters.push(`surface = ${notification.surface}`)\n  if (notification.commands) filters.push(`commands = ${notification.commands.join(', ')}`)\n  return filters.join('\\n')\n}\n", "export interface GlobalContext {\n  currentCommandId: string\n}\n\nlet _globalContext: GlobalContext | undefined\n\n/**\n * Get the global context.\n *\n * @returns Global context.\n */\nfunction getGlobalContext(): GlobalContext {\n  if (!_globalContext) {\n    _globalContext = {currentCommandId: ''}\n  }\n  return _globalContext\n}\n\n/**\n * Get the current command ID.\n *\n * @returns Current command ID.\n */\nexport function getCurrentCommandId(): string {\n  return getGlobalContext().currentCommandId\n}\n\n/**\n * Set the current command ID.\n *\n * @param commandId - Command ID.\n */\nexport function setCurrentCommandId(commandId: string): void {\n  getGlobalContext().currentCommandId = commandId\n}\n"],
  "mappings": "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",
  "names": ["notifications"]
}
